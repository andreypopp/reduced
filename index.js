// Generated by CoffeeScript 1.6.3
var END, SKIP, array, asSeq, box, drop, dropWhile, empty, filter, fold, join, lazy, makeSeq, map, mapCat, produced, promise, promiseNext, q, reduced, repeat, scan, seqProto, series, take, takeWhile, zip,
  __slice = [].slice;

q = require('kew');

SKIP = 0;

END = 1;

seqProto = {
  reduced: function(f, s) {
    return reduced(this, f, s);
  },
  produced: function() {
    return produced(this);
  }
};

makeSeq = function(next) {
  var s;
  s = Object.create(seqProto);
  s.next = next.bind(s);
  return s;
};

empty = function() {
  return makeSeq(function(done) {
    if (done) {
      return done(END);
    }
  });
};

box = function(v) {
  var seen;
  seen = false;
  return makeSeq(function(done) {
    if (!seen) {
      seen = true;
      if (done) {
        return done(null, v);
      }
    } else {
      return done(END);
    }
  });
};

array = function(a) {
  a = a.slice(0);
  return makeSeq(function(done) {
    var value;
    if (a.length > 0) {
      value = a.shift();
      if (done) {
        return done(null, value);
      }
    } else {
      return done(END);
    }
  });
};

promise = function(p) {
  var seen;
  seen = false;
  return makeSeq(function(done) {
    if (!seen) {
      seen = true;
      return p.then(function(v) {
        if (done) {
          return done(null, v);
        }
      }).end();
    } else {
      return done(END);
    }
  });
};

asSeq = function(v) {
  if ((v != null ? v.next : void 0) != null) {
    return v;
  } else if (Array.isArray(v)) {
    return array(v);
  } else if ((v != null ? v.then : void 0) != null) {
    return promise(v);
  } else if (v == null) {
    return empty();
  } else {
    return box(v);
  }
};

repeat = function(v) {
  return makeSeq(function(done) {
    return done(null, v);
  });
};

lazy = function(seqFactory) {
  var seq;
  seq = void 0;
  return makeSeq(function(done) {
    if (seq == null) {
      seq = asSeq(seqFactory());
    }
    return seq.next(done);
  });
};

map = function(seq, f) {
  seq = asSeq(seq);
  return makeSeq(function(done) {
    return seq.next(function(s, v) {
      if (s != null) {
        return done(s);
      } else {
        return done(null, f(v));
      }
    });
  });
};

scan = function(seq, f, acc) {
  seq = asSeq(seq);
  return makeSeq(function(done) {
    return seq.next(function(s, v) {
      if (s != null) {
        return done(s);
      } else {
        acc = f(v, acc);
        return done(null, acc);
      }
    });
  });
};

fold = function(seq, f, acc) {
  var computed;
  seq = asSeq(seq);
  computed = false;
  return makeSeq(function(done) {
    return seq.next(function(s, v) {
      if (computed) {
        return done(END);
      } else if (s === END) {
        computed = true;
        return done(null, acc);
      } else if (s != null) {
        return done(s);
      } else {
        acc = f(v, acc);
        return done(SKIP);
      }
    });
  });
};

take = function(seq, n) {
  if (n == null) {
    n = 10;
  }
  seq = asSeq(seq);
  return makeSeq(function(done) {
    if (n > 0) {
      n -= 1;
      return seq.next(done);
    } else {
      return done(END);
    }
  });
};

drop = function(seq, n) {
  if (n == null) {
    n = 10;
  }
  seq = asSeq(seq);
  return makeSeq(function(done) {
    if (n > 0) {
      n -= 1;
      seq.next();
      return done(SKIP);
    } else {
      return seq.next(done);
    }
  });
};

dropWhile = function(seq, f) {
  var seen;
  seq = asSeq(seq);
  seen = false;
  return makeSeq(function(done) {
    return seq.next(function(s, v) {
      if (s != null) {
        return done(s);
      }
      if (f(v) && !seen) {
        return done(SKIP);
      } else {
        seen = true;
        return done(null, v);
      }
    });
  });
};

takeWhile = function(seq, f) {
  seq = asSeq(seq);
  return makeSeq(function(done) {
    return seq.next(function(s, v) {
      if (s != null) {
        return done(s);
      }
      if (f(v)) {
        return done(null, v);
      } else {
        return done(END);
      }
    });
  });
};

filter = function(seq, f) {
  seq = asSeq(seq);
  return makeSeq(function(done) {
    return seq.next(function(s, v) {
      if (s != null) {
        return done(s);
      } else if (f(v)) {
        return done(null, v);
      } else {
        return done(SKIP);
      }
    });
  });
};

join = function(seqs) {
  var current, nextCurrent, nextSeq;
  seqs = asSeq(seqs);
  current = void 0;
  nextCurrent = function(done) {
    return current.next(function(s, v) {
      if (s === END) {
        current = void 0;
        return nextSeq(done);
      } else {
        return done(s, v);
      }
    });
  };
  nextSeq = function(done) {
    return seqs.next(function(s, seq) {
      if (s === END) {
        return done(END);
      } else {
        current = asSeq(seq);
        return nextCurrent(done);
      }
    });
  };
  return makeSeq(function(done) {
    if (!current) {
      return nextSeq(done);
    } else {
      return nextCurrent(done);
    }
  });
};

mapCat = function(seq, f) {
  return join(map(seq, f));
};

series = function(f, seed) {
  return makeSeq(function(done) {
    return asSeq(seed).next(function(s, v) {
      seed = f(v);
      return done(null, v);
    });
  });
};

zip = function() {
  var seqs;
  seqs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  if (seqs.length === 0) {
    return empty();
  }
  seqs = seqs.map(asSeq);
  return makeSeq(function(done) {
    var seq, values;
    values = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = seqs.length; _i < _len; _i++) {
        seq = seqs[_i];
        _results.push(promiseNext(seq));
      }
      return _results;
    })();
    return q.all(values).then(function(values) {
      var s, v, _i, _len, _ref;
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        _ref = values[_i], s = _ref[0], v = _ref[1];
        if (s != null) {
          return done(s);
        }
      }
      return done(null, (function() {
        var _j, _len1, _ref1, _results;
        _results = [];
        for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
          _ref1 = values[_j], s = _ref1[0], v = _ref1[1];
          _results.push(v);
        }
        return _results;
      })());
    });
  });
};

reduced = function(seq, f, s, p, n) {
  var onValue;
  if (p == null) {
    p = null;
  }
  if (n == null) {
    n = 0;
  }
  seq = asSeq(seq);
  p = p || q.defer();
  onValue = function(ns, v) {
    var nv;
    if (ns === END) {
      return p.resolve(s);
    } else {
      nv = ns === SKIP ? s : f ? f(v, s) : v;
      return setImmediate(function() {
        n = 0;
        return reduced(seq, f, nv, p, n + 1);
      });
    }
  };
  seq.next(onValue);
  return p;
};

produced = function(seq) {
  return reduced(seq, (function(v, s) {
    return s.concat([v]);
  }), []);
};

promiseNext = function(seq) {
  var p, resolve;
  p = q.defer();
  resolve = p.resolve.bind(p);
  seq.next(function(s, v) {
    if (s === SKIP) {
      return promiseNext(seq).then(resolve);
    } else {
      return resolve([s, v]);
    }
  });
  return p;
};

module.exports = {
  asSeq: asSeq,
  empty: empty,
  box: box,
  promise: promise,
  array: array,
  repeat: repeat,
  lazy: lazy,
  map: map,
  scan: scan,
  fold: fold,
  series: series,
  zip: zip,
  take: take,
  drop: drop,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  filter: filter,
  join: join,
  mapCat: mapCat,
  reduced: reduced,
  produced: produced
};
