// Generated by CoffeeScript 1.6.3
var END, SKIP, array, asSeq, box, drop, dropWhile, empty, filter, fold, join, map, mapCat, produced, promise, q, reduced, scan, take, takeWhile;

q = require('kew');

SKIP = 0;

END = 1;

empty = function() {
  return {
    depth: 1,
    next: function(done) {
      if (done) {
        return done(END);
      }
    }
  };
};

box = function(v) {
  var seen;
  seen = false;
  return {
    depth: 1,
    next: function(done) {
      if (!seen) {
        seen = true;
        if (done) {
          return done(null, v);
        }
      } else {
        return done(END);
      }
    }
  };
};

array = function(a) {
  a = a.slice(0);
  return {
    depth: 1,
    next: function(done) {
      var value;
      if (a.length > 0) {
        value = a.shift();
        if (done) {
          return done(null, value);
        }
      } else {
        return done(END);
      }
    }
  };
};

promise = function(p) {
  var seen;
  seen = false;
  return {
    depth: 1,
    next: function(done) {
      if (!seen) {
        seen = true;
        return p.then(function(v) {
          if (done) {
            return done(null, v);
          }
        }).end();
      } else {
        return done(END);
      }
    }
  };
};

asSeq = function(v) {
  if ((v != null ? v.next : void 0) != null) {
    return v;
  } else if (Array.isArray(v)) {
    return array(v);
  } else if ((v != null ? v.then : void 0) != null) {
    return promise(v);
  } else if (v == null) {
    return empty();
  } else {
    return box(v);
  }
};

map = function(seq, f) {
  seq = asSeq(seq);
  return {
    depth: seq.depth + 1,
    next: function(done) {
      return seq.next(function(s, v) {
        if (s != null) {
          return done(s);
        } else {
          return done(null, f(v));
        }
      });
    }
  };
};

scan = function(seq, f, acc) {
  seq = asSeq(seq);
  return {
    depth: seq.depth + 1,
    next: function(done) {
      return seq.next(function(s, v) {
        if (s != null) {
          return done(s);
        } else {
          acc = f(v, acc);
          return done(null, acc);
        }
      });
    }
  };
};

fold = function(seq, f, acc) {
  var computed;
  seq = asSeq(seq);
  computed = false;
  return {
    depth: seq.depth + 1,
    next: function(done) {
      return seq.next(function(s, v) {
        if (computed) {
          return done(END);
        } else if (s === END) {
          computed = true;
          return done(null, acc);
        } else if (s != null) {
          return done(s);
        } else {
          acc = f(v, acc);
          return done(SKIP);
        }
      });
    }
  };
};

take = function(seq, n) {
  if (n == null) {
    n = 10;
  }
  seq = asSeq(seq);
  return {
    depth: seq.depth + 1,
    next: function(done) {
      if (n > 0) {
        n -= 1;
        return seq.next(done);
      } else {
        return done(END);
      }
    }
  };
};

drop = function(seq, n) {
  if (n == null) {
    n = 10;
  }
  seq = asSeq(seq);
  return {
    depth: seq.depth + 1,
    next: function(done) {
      if (n > 0) {
        n -= 1;
        seq.next();
        return done(SKIP);
      } else {
        return seq.next(done);
      }
    }
  };
};

dropWhile = function(seq, f) {
  seq = asSeq(seq);
  return {
    depth: seq.depth + 1,
    next: function(done) {
      return seq.next(function(s, v) {
        if (s != null) {
          return done(s);
        }
        if (f(v)) {
          return done(SKIP);
        } else {
          return done(null, v);
        }
      });
    }
  };
};

takeWhile = function(seq, f) {
  seq = asSeq(seq);
  return {
    depth: seq.depth + 1,
    next: function(done) {
      return seq.next(function(s, v) {
        if (s != null) {
          return done(s);
        }
        if (f(v)) {
          return done(null, v);
        } else {
          return done(END);
        }
      });
    }
  };
};

filter = function(seq, f) {
  seq = asSeq(seq);
  return {
    depth: seq.depth + 1,
    next: function(done) {
      return seq.next(function(s, v) {
        if (s != null) {
          return done(s);
        } else if (f(v)) {
          return done(null, v);
        } else {
          return done(SKIP);
        }
      });
    }
  };
};

join = function(seqs) {
  var current, nextCurrent, nextSeq;
  seqs = asSeq(seqs);
  current = void 0;
  nextCurrent = function(done) {
    return current.next(function(s, v) {
      if (s === END) {
        current = void 0;
        return nextSeq(done);
      } else {
        return done(s, v);
      }
    });
  };
  nextSeq = function(done) {
    return seqs.next(function(s, seq) {
      if (s === END) {
        return done(END);
      } else {
        current = asSeq(seq);
        return nextCurrent(done);
      }
    });
  };
  return {
    depth: seqs.depth,
    next: function(done) {
      if (!current) {
        return nextSeq(done);
      } else {
        return nextCurrent(done);
      }
    }
  };
};

mapCat = function(seq, f) {
  return join(map(seq, f));
};

reduced = function(seq, f, s, p, n) {
  var onValue, yieldAfter;
  if (p == null) {
    p = null;
  }
  if (n == null) {
    n = 0;
  }
  seq = asSeq(seq);
  p = p || q.defer();
  yieldAfter = 3000 / seq.depth;
  onValue = function(ns, v) {
    var nv;
    if (ns === END) {
      return p.resolve(s);
    } else {
      nv = ns === SKIP ? s : f ? f(v, s) : v;
      if (n >= yieldAfter) {
        return setImmediate(function() {
          n = 0;
          return reduced(seq, f, nv, p, n + 1);
        });
      } else {
        return reduced(seq, f, nv, p, n + 1);
      }
    }
  };
  seq.next(onValue);
  return p;
};

produced = function(seq) {
  return reduced(seq, (function(v, s) {
    return s.concat([v]);
  }), []);
};

module.exports = {
  asSeq: asSeq,
  empty: empty,
  box: box,
  promise: promise,
  array: array,
  map: map,
  scan: scan,
  fold: fold,
  take: take,
  drop: drop,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  filter: filter,
  join: join,
  mapCat: mapCat,
  reduced: reduced,
  produced: produced
};
